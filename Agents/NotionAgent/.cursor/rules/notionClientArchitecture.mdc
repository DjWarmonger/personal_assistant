---
description: 
globs: 
alwaysApply: false
---
# Notion Client Architecture

## Overview

The architecture follows the facade pattern with clear separation between HTTP communication, business logic, and caching orchestration.

## Architecture Layers

### 1. **NotionClient (Facade)**
- **Primary Role**: Maintains backward compatibility while delegating to the new service architecture.
- **Responsibilities**:
  - Acts as the entry point for all Notion operations
  - Is called directly by Agent tools
  - Initializes and coordinates all service layer components
  - Converts exceptions to error strings for backward compatibility
- **Key Methods**: All original public methods (`get_notion_page_details`, `get_block_children`, `get_block_content`, `search_notion`, `query_database`)
- **Dependencies**: Initializes and manages `NotionAPIClient`, `CacheOrchestrator`, and `NotionService`

### 2. **NotionAPIClient (HTTP Layer)**
- **Primary Role**: Handles pure HTTP communication with the Notion API.
- **Responsibilities**:
  - Makes raw HTTP requests to Notion API endpoints
  - Manages API headers, authentication, and rate limiting coordination
  - Handles HTTP-level error responses and status codes
  - Provides clean, typed interfaces for each API endpoint
- **Core Methods**:
  - `get_page_raw()`: Fetches raw page data
  - `get_database_raw()`: Fetches raw database data
  - `get_block_children_raw()`: Fetches raw block children data
  - `search_raw()`: Performs raw search operations
  - `query_database_raw()`: Performs raw database queries
- **Features**:
  - Rate limiting integration via `AsyncClientManager`
  - Structured error handling with `HTTPError` exceptions
  - Filter parsing utilities for database queries
  - Async context manager support

### 3. **NotionService (Business Logic Layer)**
- **Primary Role**: Orchestrates business logic for Notion operations.
- **Responsibilities**:
  - Coordinates between HTTP client, cache orchestrator, and utilities
  - Implements high-level Notion functionality and workflows
  - Manages UUID/integer ID conversions and resolution
  - Handles recursive operations and tree management
  - Provides structured exception handling with custom exception types
- **Core Methods**:
  - `get_notion_page_details()`: Page/database retrieval with caching
  - `get_block_children()`: Children retrieval from cache
  - `get_block_content()`: Block content with recursive children fetching
  - `get_all_children_recursively()`: Recursive children flattening
  - `search_notion()`: Search with caching support
  - `query_database()`: Database queries with type verification
- **Features**:
  - Cache-first strategy with fallback to API
  - Recursive children fetching with cycle detection
  - Object type verification for database operations
  - Structured error handling with custom exception types

### 4. **CacheOrchestrator (Cache Management)**
- **Primary Role**: Orchestrates caching operations and cache-or-fetch patterns.
- **Responsibilities**:
  - Implements cache-or-fetch patterns for all resource types
  - Manages cache invalidation based on `last_edited_time`
  - Coordinates between `BlockCache` and `BlockManager`
  - Provides centralized cache access methods
- **Core Methods**:
  - `get_or_fetch_page()`, `get_or_fetch_database()`, `get_or_fetch_block()`
  - `get_cached_search_results()`, `cache_search_results()`
  - `get_cached_database_query_results()`, `cache_database_query_results()`
  - `verify_object_type_or_raise()`: Object type validation
- **Features**:
  - Automatic cache invalidation based on timestamps
  - Support for paginated results caching
  - Object type verification for database operations

## Data Flow & Interaction

### Typical Request Flow
1. **Client Request**: `NotionClient` receives a method call (e.g., `get_notion_page_details`)
2. **Service Delegation**: `NotionClient` delegates to `NotionService` with error handling
3. **Cache Check**: `NotionService` uses `CacheOrchestrator` to check cache first
4. **API Fallback**: If cache miss, `CacheOrchestrator` calls provided fetcher function
5. **HTTP Request**: Fetcher function uses `NotionAPIClient` for raw API call
6. **Data Processing**: `BlockManager` processes and stores raw data with UUID conversion
7. **Response**: Processed data returned as `BlockDict` through the layers

### Error Handling Strategy
- **HTTP Layer**: `HTTPError` for API communication failures
- **Service Layer**: Custom exceptions (`InvalidUUIDError`, `CacheRetrievalError`, `APIError`, etc.)
- **Facade Layer**: Converts exceptions to error strings for backward compatibility

### UUID and Integer ID Management
- **Service Layer**: Handles UUID resolution and integer ID conversion
- **Error Messages**: Uses integer IDs for user-facing error messages (e.g., "Database 123 was expected to be a database")
- **Cache Keys**: Uses UUIDs internally for cache operations
- **Public API**: Accepts both UUIDs and integer IDs, resolves appropriately

## Key Design Principles

### 1. **Separation of Concerns**
- HTTP communication isolated in `NotionAPIClient`
- Business logic centralized in `NotionService`
- Cache management delegated to `CacheOrchestrator`
- Backward compatibility maintained in `NotionClient` facade

### 2. **Dependency Injection**
- All components receive dependencies through constructor injection
- Enables easy testing with mock objects
- Clear dependency relationships and initialization order

### 3. **Async/Await Throughout**
- All API operations are async for proper concurrency
- Consistent async patterns across all layers
- Proper error propagation in async context

### 4. **Structured Exception Handling**
- Custom exception types for different error categories
- Clear error messages with relevant context
- Proper exception chaining and original error preservation

## Testing Strategy

### Layer-Specific Testing
- **NotionAPIClient**: HTTP mocking, rate limiting, error handling
- **NotionService**: Business logic, UUID resolution, recursive operations
- **CacheOrchestrator**: Cache patterns, invalidation, type verification
- **NotionClient**: Integration testing, backward compatibility

### Mock Strategy
- `NotionAPIClient`: Mock HTTP responses and rate limiting
- `CacheOrchestrator`: Mock cache operations and invalidation
- `Index`: Mock UUID/integer ID conversions with proper return types
- Service dependencies: Mock all external dependencies for isolation

## Migration and Compatibility

### Backward Compatibility
- `NotionClient` maintains exact same public API
- Error handling converts exceptions to error strings as before
- All existing tests pass without modification
- Agent tools continue to work without changes

### Benefits of Refactoring
- **Maintainability**: Clear separation of concerns and responsibilities
- **Testability**: Each layer can be tested in isolation
- **Extensibility**: Easy to add new features or modify existing behavior
- **Debugging**: Clear error boundaries and structured exception handling
- **Performance**: Optimized caching patterns and reduced redundancy

## Future Development Guidelines

### Adding New Features
- **HTTP Operations**: Add new methods to `NotionAPIClient`
- **Business Logic**: Implement in `NotionService` with proper error handling
- **Caching**: Use `CacheOrchestrator` patterns for cache-or-fetch operations
- **Public API**: Add facade methods to `NotionClient` for backward compatibility

### Error Handling
- Use appropriate custom exception types in service layer
- Maintain integer ID format for user-facing error messages
- Ensure proper exception conversion in facade layer

### Testing New Features
- Test each layer independently with appropriate mocks
- Verify integration through facade layer
- Maintain backward compatibility in public API
- Follow async/await patterns consistently

